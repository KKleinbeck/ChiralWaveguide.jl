<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Displaced States · ChiralWaveguide</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="ChiralWaveguide logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ChiralWaveguide</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Simulating 1d chiral quantum systems</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Displaced States</a><ul class="internal"><li><a class="tocitem" href="#Continuous-wave-input"><span>Continuous wave input</span></a></li><li><a class="tocitem" href="#Coherent-state-input"><span>Coherent state input</span></a></li><li><a class="tocitem" href="#Accessing-the-input-cavity"><span>Accessing the input cavity</span></a></li><li><a class="tocitem" href="#Mollow-transformation-on-the-output-cavity"><span>Mollow transformation on the output cavity</span></a></li></ul></li><li><a class="tocitem" href="../SinglePhotonScattering/">Scattering of a single photon</a></li><li><a class="tocitem" href="../CustomModes/">Creating custom modes</a></li><li><a class="tocitem" href="../CustomSystems/">Defining the quantum system</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Displaced States</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Displaced States</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KKleinbeck/ChiralWaveguide.jl/blob/master/docs/src/examples/CoherentInput.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Displaced-States"><a class="docs-heading-anchor" href="#Displaced-States">Displaced States</a><a id="Displaced-States-1"></a><a class="docs-heading-anchor-permalink" href="#Displaced-States" title="Permalink"></a></h1><p><em>ChiralWaveguide.jl</em> is designed with efficiency in mind. One of the tricks used to make calculations more efficient is the Mollow transform. The Mollow transform allows to take the displacement out of every displaced state (e.g., <a href="../../api/#ChiralWaveguide.DisplacedFock"><code>DisplacedFock</code></a>) and put it into the Hamiltonian. This drastically reduces the size of the input Hilbert space - for a coherent state we can even remove the input cavity entirely. If for some reason, the full input cavity needs to be included, this can be manually achieved, at the loss of performance of course.</p><p>In this example we discuss <a href="../../api/#ChiralWaveguide.ContinuousWave"><code>ContinuousWave</code></a>, a special implementation of coherent states which generally provide the fastest implementation of a constant coherent state input. We will compare this to alternative implementations, to discuss their particular implementation and use cases.</p><h2 id="Continuous-wave-input"><a class="docs-heading-anchor" href="#Continuous-wave-input">Continuous wave input</a><a id="Continuous-wave-input-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-wave-input" title="Permalink"></a></h2><p>Let&#39;s simulate a two level atom driven by a constant coherent light field. We use <a href="../../api/#ChiralWaveguide.ContinuousWave"><code>ContinuousWave</code></a> for this. Using <a href="../../api/#ChiralWaveguide.Coherent"><code>Coherent</code></a> states works as well, and we will discuss this below. It should be noted, however, that coherent states should always describe proper modes, i.e., normalisable wave functions, while continuous waves relax this condition.</p><p>To compare the performance with the other implementations we use <code>BenchmarkTools</code> <code>@btime</code> macro</p><pre><code class="nohighlight hljs">tf = 5.0
α  = 1.0

problem = WaveguideProblem(TwoLevelChain(1), ContinuousWave(α), tf)
ts, ρs = @btime solve($problem) # 78.560 μs (367 allocations: 39.05 KiB)</code></pre><p><code>ContinuousWave</code> does two things to make the simulation fast: Firstly, it tells the solver that the input is a coherent state and therefore the input cavity can be eliminated from the start. This can be seen by</p><pre><code class="nohighlight hljs">basis(ρs[end]) # NLevel(N=2)</code></pre><p>i.e., <code>ρs</code> only stores the state of the atom. Secondly, if a constant is passed to <code>ContinuousWave</code> the solver knows that the master equation is time independent and falls back to a faster implementation for time-independent master equations. Of course <code>ContinuousWave</code> can also describe time dependence, but loosing the second advantage by doing so:</p><pre><code class="nohighlight hljs">problem = WaveguideProblem(TwoLevelChain(1), ContinuousWave(t -&gt; α), tf)
ts, ρs = @btime solve($problem) # 1.157 ms (20997 allocations: 1.84 MiB)</code></pre><p>Already in this minimalistic example the difference is substantial.</p><h2 id="Coherent-state-input"><a class="docs-heading-anchor" href="#Coherent-state-input">Coherent state input</a><a id="Coherent-state-input-1"></a><a class="docs-heading-anchor-permalink" href="#Coherent-state-input" title="Permalink"></a></h2><p>Using <code>Coherent</code> instead of <code>ContinuousWave</code> primarily expresses the intent of using a proper mode, instead of a non-normalisable driving function. Yet, the solver internally only uses the mode function of the specified mode, so it is possible to implement a continuous input with <code>Coherent</code></p><pre><code class="nohighlight hljs">problem = WaveguideProblem(
  TwoLevelChain(1),
  WavePacket(Mode(t -&gt; 1., t -&gt; 0., t -&gt; 0., t -&gt; 0.), Coherent(α)),
  tf
)
ts, ρs = @btime solve($problem) # 1.105 ms (20997 allocations: 1.84 MiB)</code></pre><p>This provides the same performance as the time-independent implementation of <code>ContinuousWave</code>; in fact, this is how <code>ContinuousWave</code> is implemented for time dependent arguments. However, this manual hack is discouraged, as <code>ContinuousWave</code> provides a simpler interface, that clearly expresses its intend and is potentially faster for constant driving amplitudes. For normalisable wave functions both <code>Coherent</code> and <code>ContinuousWave</code> are practically interchangeable, but it is still recommended to use <code>Coherent</code>, as in the last example, to express clear intend.</p><h2 id="Accessing-the-input-cavity"><a class="docs-heading-anchor" href="#Accessing-the-input-cavity">Accessing the input cavity</a><a id="Accessing-the-input-cavity-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-the-input-cavity" title="Permalink"></a></h2><p>All previous examples eliminate the input cavity in favour for better performance. If one wants to access the precise population of the input mode however, we can save the coherent number distribution in <a href="../../api/#ChiralWaveguide.ArbitraryState"><code>ArbitraryState</code></a>. This needs a little boilerplating</p><pre><code class="nohighlight hljs">N_cutoff = ceil(Int, tf * α^2 + 5 * √(tf) * α)
amplitudes = coherentstate(FockBasis(N_cutoff), √(tf) * α).data
state = ArbitraryState(amplitudes)</code></pre><p>First, a cutoff is choosen, so that the coherent state fits reasonably well in the Hilbert space (here <code>sum(abs2, amplitudes) == 0.9999...</code>). Then we use <em>QuantumOptics.jl</em> <code>coherentstate</code> to get the amplitudes and create our input state. Notice, we choose an amplitude <code>√(tf) * α</code> and not <code>α</code>, since we use <code>HardBoxMode</code> as our mode function, which introduces a normalisation factor <code>1/√(tf)</code>. Here it is important that we use a proper normalisable mode, since we need to access <code>gᵢ</code>. The simulation now becomes</p><pre><code class="nohighlight hljs">problem = WaveguideProblem(TwoLevelChain(1), WavePacket(HardBoxMode(σ = tf), state), tf)
ts, ρs_full = @btime solve($problem) # 207.809 ms (138290 allocations: 516.25 MiB)</code></pre><p>and is significantly the slowest version. Yet, we now may observe the input cavity and its entanglement with the quantum system or output cavity</p><pre><code class="nohighlight hljs">basis(ρs_full[end]) # [Fock(cutoff=17) ⊗ NLevel(N=2)]</code></pre><p>Lastly, we verify that this approach yields the correct result for the atom&#39;s state</p><pre><code class="nohighlight hljs">ρs_atoms = [ptrace(ρ, 1) for ρ ∈ ρs_full]
all(tracedistance.(ρs_atoms, ρs) .&lt; 2e-5) # true</code></pre><h2 id="Mollow-transformation-on-the-output-cavity"><a class="docs-heading-anchor" href="#Mollow-transformation-on-the-output-cavity">Mollow transformation on the output cavity</a><a id="Mollow-transformation-on-the-output-cavity-1"></a><a class="docs-heading-anchor-permalink" href="#Mollow-transformation-on-the-output-cavity" title="Permalink"></a></h2><p>Let us now introduce an output cavity to the problem. If we assume for the moment, that there is no quantum system between the input and output cavity, then the time evolution of the state <span>$\rho$</span> of the output cavity follows the master equation</p><p class="math-container">\[\begin{aligned}
	\partial_t \rho   &amp;= -i[H_\mathrm{drive}, \rho] + \mathcal{D}[\rho], \\
	H_\mathrm{drive}  &amp;= i(\alpha^*(t) g_v^*(t) b - \alpha(t) g_v(t) b^\dagger), \\
	\mathcal{D}[\rho] &amp;= |g_v(t)|^2 \Big[b \rho b^\dagger - \frac{1}{2} \{b^\dagger b, \rho\}\Big],
\end{aligned}\]</p><p>with <span>$g_v(t)$</span> the coupling rate of the output cavity. The solution to this master equation for an initially de-excited cavity is a coherent state<span>$\rho(t) = |\beta(t) \rangle\langle \beta(t)|$</span> with the amplitude</p><p class="math-container">\[\begin{equation}
  \beta(t) = - \int_0^t ds \alpha(s) g_v(s).
\end{equation}\]</p><p>This implies that, independent of the quantum system, we may expect that we need a large Fock basis for the output cavity of the order of <span>$|\alpha|^2$</span>. However, we may perform a Mollow transformation on the output cavity and eliminate <span>$H_\mathrm{drive}$</span> from the Master equation and thus save precious memory and make the simulations faster. This becomes especially attractive when we are only interested in the final state <span>$\rho(t_f)$</span>, when <code>\alpha(t_f) = 0</code> or <code>g_v(t_f) = 0</code>, so that we can exactly determine the displacement. For example, for constant <span>$\alpha$</span> and a flat mode of width <span>$\sigma$</span> we find <span>$\beta(t_f) = \sqrt{\sigma} \alpha$</span>.</p><p>Okay, let&#39;s see this trick in action. In the simulation we can tell <em>ChiralWaveguide.jl</em> to do the Mollow transform by setting the <code>displace_output</code> flag to <code>true</code>:</p><pre><code class="nohighlight hljs">probNonDisp = WaveguideProblem(TwoLevelChain(1), ContinuousWave(α), HardBoxMode(σ = tf), tf)
probDisp    = WaveguideProblem(TwoLevelChain(1), ContinuousWave(α), HardBoxMode(σ = tf), tf, true)

ts, ρsNonDisp = @btime solve($probNonDisp) # 121.945 ms (144023 allocations: 357.63 MiB)
ts, ρsDisp    = @btime solve($probDisp)    # 16.258 ms (57298 allocations: 53.28 MiB)</code></pre><p>The strong improvement is of course due to the smaller Fock basis in the displaced case</p><pre><code class="nohighlight hljs">ρCavNonDisp = ptrace(ρsNonDisp[end], 1)
ρCavDisp    = ptrace(ρsDisp[end],    1)

basis(ρCavNonDisp) # Fock(cutoff=14)
basis(ρCavDisp)    # Fock(cutoff=7)</code></pre><p>Yet, If we account for the displacement the results coincide nicely</p><pre><code class="nohighlight hljs">using GSL, SpecialFunctions
function displaceProper(basis, α)
	operator = DenseOperator(basis)

	αc, α2, eα2 = -conj(α), abs2(α), exp(-0.5abs2(α))

	for m ∈ 1:basis.N
		operator.data[m, m] = eα2 * sf_laguerre_n(m - 1, 0, α2)
		for n ∈ m:basis.N+1
			c = √(gamma(m)/gamma(n)) * eα2 * sf_laguerre_n(m - 1, n-m, α2)
			operator.data[m, n] = c * αc^(n-m)
			operator.data[n, m] = c * α^(n-m)
		end
	end
	return operator
end

D = displaceProper(basis(ρCavNonDisp), sqrt(tf) * α)
sqrt(sum(abs2, (D&#39; * ρCavNonDisp * D).data[1:8,1:8] - ρCavDisp.data)) # 0.0023699962743152143</code></pre><p>Manually changing <code>Nouts</code> in <code>solve</code> reveals that the difference is mainly due to the basis size of the <em>non displaced</em> implementation, i.e., the Mollow transformation is even more accurate. Finally notice, we implemented our own version of the displacement operator and did not use <code>displace</code> from <a href="https://qojulia.org/">QuantumOptics.jl</a>, as this version do not provide correct matrix coefficient for any truncated Fock basis (it is however unitary, contrary to our implementation).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Simulating 1d chiral quantum systems</a><a class="docs-footer-nextpage" href="../SinglePhotonScattering/">Scattering of a single photon »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Monday 24 January 2022 10:27">Monday 24 January 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
